#include "config.h"
#include "mmam.h"
#include "qfe.h"
#include "rand.h"
#include "fonts.h"
#include "albgi.h"
#include "graphs.h"

graph_set *graphs;

#define money_id DAT_ID('M','O','N','Y')
#define fame_id DAT_ID('F','A','M','E')
#define tourists_id DAT_ID('T','O','U','R')
#define ticket_price_id DAT_ID('T','I','C','K')
#define sweetness_points_id DAT_ID('S','W','P','T')
#define gened_sp_id DAT_ID('G','N','S','P')
#define penalty_id DAT_ID('P','E','N','L')

int graph_line::correct_color_by_section(int sel, int col) {
    switch (sel) {
	case money_id:            return LightGreen;
	case fame_id:             return LightBlue;
	case tourists_id:         return LightRed;        
	case ticket_price_id:     return Yellow;        
	case sweetness_points_id: return White;        
	case gened_sp_id:         return Cyan;        
	case penalty_id:          return Brown;
    }
    return col; 
}

void graph_line::put_header(PACKFILE *set_pf, char *sname, int ssection_code) {
	pf = set_pf;
	name = strdup(sname); 
	section_code = ssection_code;  
	color = correct_color_by_section(section_code, White);
	if (name) pack_fputs(name, pf); pack_fputs("\n", pf);
	pack_mputl(section_code, pf);
	pack_mputl(color, pf);	    
}    

void graph_line::load_header(PACKFILE *set_pf, int version) {
	char buf[256];
	pf = set_pf;
	pack_fgets(buf, sizeof(buf), pf);
    buf[strlen(buf)] = 0; // kill linefeed
	name = strdup(buf);
	section_code = pack_mgetl(pf);
    if (section_code>=0 && section_code<=6) {
         // compatiblity with files generated by old code.
         // can probably wipe out later.
         int old_style_id_fix[7] = {
         	money_id, fame_id, tourists_id, 
         	ticket_price_id, sweetness_points_id, gened_sp_id, penalty_id
         };    
         section_code = old_style_id_fix[section_code];
	}
	color = correct_color_by_section(section_code, pack_mgetl(pf));
	fprintf(stderr, "[%s %i %i]\n",name, section_code, color);	      
}

void graph_line::append_data(int dataitm) {
	data[on_sec] = dataitm;
	if (dataitm < min) min = dataitm;
	if (dataitm > max) max = dataitm;
	pack_mputl(dataitm, pf);
	if (++on_sec == graph_line_hold_secs) on_sec = 0;
	if (++valid_secs >= graph_line_hold_secs) valid_secs = graph_line_hold_secs; 
}

void graph_line::pf_append_data() {
	int dataitm = pack_mgetl(pf);
	data[on_sec] = dataitm;
	if (dataitm < min) min = dataitm;
	if (dataitm > max) max = dataitm;
	if (++on_sec == graph_line_hold_secs) on_sec = 0;
	if (++valid_secs >= graph_line_hold_secs) valid_secs = graph_line_hold_secs; 
}


int graph_line::get_sec_ago(int delta_t) {
	if (delta_t < 0) delta_t = 0;
	if (delta_t >= valid_secs) return 0;
	int ix = on_sec - delta_t - 1;
	if (ix < 0) ix = valid_secs + ix;
	return data[ix];
}

int graph_line::set_minmax(int delta_t, int count) {
	min = max = 0; 
	for (int i = 0; i < count; i++) {
		int v = get_sec_ago(delta_t + i);
		if (v < min) min = v;
		if (v > max) max = v;            
	}
	return max - min;
}    


// ------------------------------------------------------------------------
    
void graph_set::set_draw_zone(int sx, int sy, int sw, int sh) {
		x = sx; y = sy; w = sw; h = sh;
}

void graph_set::draw(BITMAP *out, int blackout) {
        if (!out || !disp_seconds) return;
		if (blackout) rectfill(out, x, y, x+w-1, y+h-1, Black);
		for (int sc = 0; sc < disp_seconds; sc += 60) {
			int x0 = x + w - (w * sc / disp_seconds) - 1;                
			vline(out, x0, y, y+h-1, DarkGray);
		}
		int x0 = x + w - (w * (tracker_line - right_hand) / disp_seconds) - 1;                
		
		vline(out, x0, y, y+h-1, LightGray);		
		
		int x1m = x + w - (w * 60 / disp_seconds) + 1;
		textout_ex(out, &font_micro, "1min", x1m, y+4, DarkGray, -1);
		for (int i = num_graphs - 1; i >= 0; i-- ) if (graph[i].display == 1) {
			int dat, x0, x1, y0, y1;
			int vsec = 0;
			int rng = graph[i].set_minmax(right_hand, disp_seconds);
			for (int sc = 0; sc < disp_seconds; sc++) {
				dat = graph[i].get_sec_ago(sc + right_hand); 
				x0 = x1; 
				x1 = x + w - (w * sc / disp_seconds) - 1;
				y0 = y1; 
				y1 = y + h - (rng ? h * (dat - graph[i].min) / rng : 0) - 1;
				if (sc) {
					line(out,x0,y0,x1,y1, graph[i].color);
				}
			} 
		}
		int yy = y+4; int colwid = 0;
		for (int i = 0; i < num_graphs; i++ ) if (graph[i].display) {
			int cw = text_length(&font_micro, graph[i].name) + 6;
			if (cw > colwid) colwid = cw;     	
		}
		
		for (int i = 0; i < num_graphs; i++ ) if (graph[i].display) {
			int col = graph[i].display == 2 ? DarkGray : graph[i].color;
			textprintf_ex(out, &font_micro, x+4, yy, col, -1, "F%i", i+1);
			textout_ex(out, &font_micro, graph[i].name, x+30, yy, col, -1);
			textprintf_ex(out, &font_micro, x+30+colwid, yy, col, -1, "%i(%i)", graph[i].get_sec_ago(tracker_line), graph[i].max);
			yy += 2 + text_height(&font_micro);     	
		}
		char time_str[20];
		snprintf(time_str, sizeof time_str, "%i:%02i", (time-tracker_line)/60, (time-tracker_line)%60);
		textprintf_ex(out, &font_micro, 
		    x0 + (x0 > x+5*w/6 ? -2 - text_length(&font_micro, time_str) : 2), y+h-22, 
			LightGray, -1, "%s", time_str
		);		
		rect(out, x, y, x+w-1, y+h-1, White);
		
}

void graph_set::display_only_user() {
	for (int i=0; i < num_graphs; i++) {
		switch (graph[i].section_code) {
	    case money_id:
	    case fame_id:
	    case tourists_id:       
	    case ticket_price_id: graph[i].display = 1; break;        
		default: graph[i].display = 0;
		}   
	}    
}

void graph_set::display_only_alignment() {
	for (int i=0; i < num_graphs; i++) {
		switch (graph[i].section_code) {
		default: graph[i].display = 0;
		}   
	}    
}

/*
  case sweetness_points_id: return White;        
  case gened_sp_id:         return Cyan;        
  case penalty_id:          return Brown;
*/

void graph_set::display_all() {
	for (int i=0; i < num_graphs; i++) graph[i].display = 1;
}
    

int graph_set::handle_input(int mode) {
	if (mode == 0 && keypressed()) return 0;
	int has_mouse = 0;
	if (mode > 0) {
		if (
			mouse_x >= x &&
			mouse_x <= x+w-1 &&
			mouse_y >= y &&
			mouse_y <= y+h-1
		) {
			has_mouse = 1;
		}
	}
	if (mode && keypressed()) {
	    int scrollzone = disp_seconds * 5 / 6;
	    int scrollzone2 = disp_seconds / 6;
	    int k = (readkey() >> 8);
	    int gtoggle = -1;
	    int zlm = 0;
	    int ch_load_last_ofs = 0;
	    int jump_sec = (
	    	key_shifts & KB_SHIFT_FLAG ? 1 :
	    	key_shifts & KB_CTRL_FLAG ? scrollzone :
	        MAX(disp_seconds / 20, 1)  
	    );
	    switch (k) {
	    case KEY_ESC: return 0;
	    case KEY_TAB: if (mode == 1) return 0;
	    case KEY_LEFT: 
	    	if (!has_mouse){ 
	    		tracker_line += jump_sec; 
	    		if (tracker_line > right_hand + scrollzone && time - right_hand > 0) right_hand += jump_sec; 
	    	} else {
	    	    right_hand += jump_sec;
	    	}
	    	break;
	    case KEY_RIGHT: 
	    	if (!has_mouse){ 
	    		tracker_line -= jump_sec; 
	    		if (tracker_line < right_hand && right_hand > 0) right_hand -= jump_sec;
	    	} else {
                right_hand -= jump_sec;	    	
	    	}
	    	break;
	    case KEY_UP:
	    case KEY_MINUS_PAD:
	    case KEY_MINUS: zlm = 1; break; 
	    case KEY_PLUS_PAD:
	    case KEY_DOWN:
	    case KEY_EQUALS: zlm = -1; break;
        case KEY_F1:  gtoggle =  0; break;
        case KEY_F2:  gtoggle =  1; break;
        case KEY_F3:  gtoggle =  2; break;
        case KEY_F4:  gtoggle =  3; break;
        case KEY_F5:  gtoggle =  4; break;
        case KEY_F6:  gtoggle =  5; break;
        case KEY_F7:  gtoggle =  6; break;
        case KEY_F8:  gtoggle =  7; break;
        case KEY_F9:  gtoggle =  8; break;
        case KEY_F10: gtoggle =  9; break;
        case KEY_F11: gtoggle = 10; break;
        case KEY_F12: gtoggle = 11; break;
        case KEY_PGUP: if (mode == 2) ch_load_last_ofs = 1; break;
        case KEY_PGDN: if (mode == 2) ch_load_last_ofs = -1; break;
	    }
	    if (zlm && num_graphs) {
	    	static int zoom_levels[] = {60,60, 180, 300, 600, 1800, 3600, 3600};
	       	int i = 1;
	    	for (;disp_seconds < zoom_levels[i] && zoom_levels[i] != 3600; i++ );
	    	disp_seconds = zoom_levels[i+zlm];
	    	if (disp_seconds > graph[0].valid_secs) {
	    	     disp_seconds = graph[0].valid_secs;	    	     
	    	} 
	    	if (disp_seconds + right_hand > graph[0].valid_secs) {
	    	     right_hand = graph[0].valid_secs - disp_seconds;
	    	}	   
	    }
	    if (gtoggle >= num_graphs ) gtoggle = -1;
	    if (gtoggle >= 0 && graph[gtoggle].display) {
	       graph[gtoggle].display = graph[gtoggle].display == 2 ? 1 : 2;
	    }
	    if (ch_load_last_ofs) load_last(load_last_ofs+ ch_load_last_ofs); 
	}
	if (has_mouse) tracker_line = (disp_seconds * ((x + w - 1) - mouse_x) / w)	 + right_hand;	    
	return 1;
}

int graph_set::load(char *fn) {
	kill();
	char buf[256];
	pf = pack_fopen(fn, "r");
	if (!pf) { 
		// allegro_message("graph file '%s' open failed.", fn);
		return 0;
	}
	pack_fgets(buf, sizeof(buf), pf);
	if (strcmp(buf, "mmamgraph-1") != 0) {
			pack_fclose(pf); pf = NULL; 
			// allegro_message("graph file '%s' has an invalid header: '%s'.", fn, buf);
			return 0;
	}
	version = 1;
	num_graphs = pack_mgetl(pf);
	graph = new graph_line[num_graphs];
	for (int i = 0; i < num_graphs; i++) graph[i].load_header(pf, version);	     
	while (!pack_feof(pf)) {
		char op = pack_getc(pf);
		char opo[] = "[.] ";  opo[1] = op;  fprintf(stderr, opo);
		switch (op) {
		case 'D': /*data*/ { time++; for (int i = 0; i < num_graphs; i++) graph[i].pf_append_data(); break; }
		case 'Y': /*display*/{ int ix = pack_mgetl(pf); graph[ix].display = pack_getc(pf); break; }
        case 'E': /*event*/
        case 'S': /*screenshot*/
        case 'A': /*auto screenshot*/
        case 'N': /*note*/  { pf_load_note(op); break; }
		default: /* allegro_message("graph file '%s' is corrupt.", fn);*/ pack_fclose(pf); pf = NULL; return 0;
		}
	}
	// allegro_message("graph file '%s' ok:  time (%i:%02i).", fn, time/60, time%60);
			
	pack_fclose(pf); pf = NULL;
	
	return 1;
}

int graph_set::load_last(int ofs) {
	char fn[256];
	int i = 0;
	load_last_ofs = ofs;
	do {
		if (i++ > 999) break;
	    snprintf(fn, sizeof fn, "%sgraphs%03i.mgset", scr_shot_dir, i);
	} while (exists(fn));
	i -= (1 + ofs); 
	snprintf(fn, sizeof fn, "%sgraphs%03i.mgset", scr_shot_dir, i);
	
	if (i >= 1) return load(fn);	
	return 0;         
}

int graph_set::build_new_set() {
	kill();        
	char fn[256];
	int i = 1;
	do {
		snprintf(fn, sizeof fn, "%sgraphs%03i.mgset", scr_shot_dir, i);
		if (i++ > 999) return 0;
	} while (exists(fn));
	pf = pack_fopen(fn, "w");
	if (!pf) {
	    allegro_message("could not build: %s\n", fn);
	    return 0;
    }	
    // allegro_message("built: %s\n", fn);	
    albgi_init();
    pack_fputs("mmamgraph-1\n", pf);
	num_graphs = 7;        
	pack_mputl(num_graphs, pf);	    
	graph = new graph_line[num_graphs];
	graph[0].put_header(pf, (char *) "money",            money_id);
	graph[1].put_header(pf, (char *) "fame",             fame_id);
	graph[2].put_header(pf, (char *) "tourists",         tourists_id);        
	graph[3].put_header(pf, (char *) "ticket price",     ticket_price_id);        
	graph[4].put_header(pf, (char *) "sweetness points", sweetness_points_id);        
	graph[5].put_header(pf, (char *) "gened sp",         gened_sp_id);        
	graph[6].put_header(pf, (char *) "penalty",          penalty_id);        
	// allegro_message("built: %s\n", fn);	    
	return 1;
}

void graph_set::feed_graphs(int money, int fame, int tourists, int ticket_price, int sweetness, int gen_sp, int penalty) {
	if (num_graphs != 7 || !pf) return;
	time++;
	int hdr = 'D';
	pack_putc(hdr, pf);
	graph[0].append_data(money);
	graph[1].append_data(fame);
	graph[2].append_data(tourists);
	graph[3].append_data(ticket_price);
	graph[4].append_data(sweetness);
	graph[5].append_data(gen_sp);
	graph[6].append_data(penalty);
}

void graph_set::pf_load_note(char style) {
	// construct a note record in memory (very hackish)
	int asiz = pack_mgetl(pf);
	void *vp = malloc( sizeof(int) + 1 + asiz);
    int *tp = (int *)vp;
    char *sp = (char*)vp + sizeof(int);
    char *np = (char*)vp + sizeof(int) + 1;
    *tp = time;
    *sp = style;
    pack_fread(np, asiz, pf);	
	if (note[on_note]) free(note[on_note]);
	note[on_note] = vp;
	if (++on_note == graph_set_hold_notes) on_note = 0;
	if (++valid_notes >= graph_set_hold_notes) {
	    valid_notes = graph_set_hold_notes;
	    free(note[on_note]);
	}
}


void graph_set::notestr_add(char style, char *notestr) {
	// construct a note record in memory (very hackish)
	if (!notestr) return;
	int wb = strlen(notestr) + 1;
	void *vp = malloc(sizeof(int) + 1 + wb);
    int *tp = (int *)vp;
    char *sp = (char*)vp + sizeof(int);
    char *np = (char*)vp + sizeof(int) + 1;
    *tp = time;
    *sp = style;
    memcpy(np, notestr, wb);	
	if (note[on_note]) free(note[on_note]);
	note[on_note] = vp;
	if (++on_note == graph_set_hold_notes) on_note = 0;
	if (++valid_notes >= graph_set_hold_notes) {
	    valid_notes = graph_set_hold_notes;
	}
	if (!pf) return;        
	pack_putc(style, pf);
	pack_mputl(wb, pf);
	pack_fwrite(note, wb, pf);
}

char *graph_set::get_notestr_from_sec_ago(int delta_t, int guess_ix, char &style, int &index) {
    int look4 = time - delta_t;
    style = 0;
    index = guess_ix;
    while (1) { 
		guess_ix--;
		if (guess_ix < 0) {
			guess_ix = graph_set_hold_notes - 0;
			if (valid_notes != graph_set_hold_notes) return NULL;
		}
		int *tp = (int *)note[guess_ix];
		if (look4 == *tp) {
				index = guess_ix;
				char *cp = (char *)tp; cp += (sizeof(int));
				style = *cp;
				return cp + 1;  
		} else if (look4 > *tp) return NULL;
		if (index == guess_ix) return NULL;		 
    } 
}    
