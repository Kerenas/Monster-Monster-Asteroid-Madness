#! /usr/bin/perl
use strict;
my $outmode = 1;
my ($SP, $AB);
$| = 0;
my (
	$output, $ast_list, $gr_spr, $last_pre, $lvl_count, $by_nam,
	%have_sounds, %have_sprites, @firsts, %auto_count, $recno, @needspr, @needsnd, $fix_desc_func,
	@auto_mbl, @full_mbl, %has_big, %has_chill, %has_die
);

sub load_sprites_h() {
	open S, "sprites.h" or die "could not open sprites.h";
	my $num_surfaces;
	my @sl;
	while (defined (my $ln = <S>)) {
		$have_sprites{$1} = 1 if ($ln =~ /#define\s+(.*?)\s/);
		$num_surfaces = $1 if ($ln =~ /#define NUM_SURFACES (.*?)\n/);
	}
	for (0 .. $num_surfaces - 1) {
		my $spr = 'A' . chr((ord 'A') + $_) . '0001';
		push @needspr, $spr;
		push @sl, "SPR_" . $spr;
	}
	$ast_list = join ', ', @sl;
	close S;
}

sub load_sounds_h() {
	open S, "sounds.h" or die "could not open sounds.h";
	my $num_surfaces;
	my @sl;
	while (defined (my $ln = <S>)) {
		$have_sounds{$1} = 1 if ($ln =~ /#define\s+(.*?)\s/);		
	}
	close S;
}


sub load_monstbase_cc() {
	open MB, "monstbase.cc" or die "could not open monstbase.cc";
	my @mbln = <MB>;
	foreach (grep /^ *monst_base +[^ ]* *= *.*/, @mbln) {
		/^ *monst_base +([^ ]*)/;
		push @full_mbl, "&$1";
	}
	my @spl;
	foreach my $ln (@mbln) {
		while ($ln =~ s/[^A-Z](A|W|Y|G)\((.*?)\)//) {
			my $s = "$2"; $s =~ s/,.*//;
			push @spl, $s if $s ne 'idx';
		}
		while ($ln =~ s/SPR_(QBLD|QSHIP)\(.*?, *(.*?), *(.*?)\)//) {
			push @spl, $2 if $2 ne 'idx';
			push @spl, $3 if $3 ne 'idx';
		}
		if ($ln =~ /SPR_BIG\( *(.*?), *(.*?) *\)/) {   $has_big{$1} = 1; push @spl, $2;}
		if ($ln =~ /SPR_CHILL\( *(.*?),/) { $has_chill{$1} = 1; }
		if ($ln =~ /SPR_DIE\( *(.*?),/) {   $has_die{$1} = 1; }
	}
	print "need sprites {" . join(", ", @spl) . "}\n";
	push @needspr, @spl;
	close MB;
}

sub write_patch_header() {
	  	print $SP "/* sprite_patch.h generated by trader_strip.pl */\n";
		print $SP qq|
#ifndef _sprite_patch_h
#define _sprite_patch_h 1

#ifdef INV_DEF_MACROS
#  define UP(typ, nam, lvl, sv, jm, cost, common, inv_sprite) {typ, -1, nam, NULL, lvl, sv, -1, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, -1, -1, -1, -1, -1, -1, NULL}
#  define CAGE( nam, lvl, sv, jm, cost, common, inv_sprite, lil_sprite) {inv_cage, -1, nam, NULL, lvl, sv, -1, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, SPR_ ## lil_sprite,SPR_ ##  lil_sprite ## _BROKEN, -1, -1, -1, -1, NULL}
#  define CLAW( nam, lvl, sv, jm, cost, common, inv_sprite, lil_sprite) {inv_claw_up, -1, nam, NULL, lvl, sv, -1, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, SPR_ ## lil_sprite,SPR_ ##  lil_sprite ## _CLOSED, -1, -1, -1, -1, NULL}
#  define HULL( nam, lvl, sv, jm, cost, common, inv_sprite, lil_sprite) {inv_hull_up, -1, nam, NULL, lvl, sv, -1, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, SPR_ ## lil_sprite, SPR_ ## lil_sprite, -1, -1, -1, -1, NULL}
#  define AUTO( typ, nam, sv, jm, cost, common, lil_sprite) {typ, -1, nam, NULL, -1, sv, -1, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## lil_sprite ## _INV, SPR_ ## lil_sprite,-1, -1, -1, -1, -1, NULL}
#  define DEPL( typ, nam, lvl, sv, pow_tox, size, hp, jm, cost, common, inv_sprite, lil_sprite) {typ, -1, nam, NULL, lvl, sv, pow_tox, -1, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, -1, -1, -1, -1, -1, -1, NULL}
#  define PROJ( wtyp, nam, dam_sv, tox, drg, grp, rng, vel, relms, jm, cost, common, inv_sprite, projs, hx, hy, ws1, ws2, noise ) {inv_proj, wtyp, nam, NULL, -1, dam_sv, tox, drg, grp, rng, vel, relms, jm, cost, common, SPR_ ## inv_sprite, SPR_ ## ws1, SPR_ ## ws2, SPR_ ## projs, hx, hy, SND_ ## noise, NULL}
#  define THRUST( nam, lvl, fthr_sv, lthr_tox, trate_drg, jm, cost, common, inv_sprite ) {inv_thrust_up, -1, nam, NULL, lvl, fthr_sv, lthr_tox, trate_drg, 1, -1, -1, -1, jm, cost, common, SPR_ ## inv_sprite, -1, -1, -1, -1, -1, -1, NULL}
#endif

typedef enum inv_t {
	inv_none, inv_repair, inv_hint, inv_money, inv_donation,
	inv_claw_up, inv_rope_up, inv_cage_stat_up,
	inv_thrust_up, inv_claw_speed_up, inv_hull_up,
	inv_food, inv_injector, inv_cage, inv_proj, inv_mineral,
	inv_scanner, inv_tower, inv_power, inv_stabilizer, inv_encl
};

typedef struct ivalu_t {
  int typ, wtyp; char *nam, *desc;
  int lvl, sv, tox, drg, grp, rng, vel, relms, jm, cost, common,
      inv_sprite, ws1, ws2, projs, hx, hy, noise;
  struct monst_base *mb_link;
};

void fix_ivalu_desc();

|;

}

sub write_monstbase_h {
	open MBH, ">monstbase.h" or die "can't open monstbase.h for writing.";

	print MBH  "/* generated by trader_strip.pl (do not hand edit.) */\n";
	print MBH  "\n";
	print MBH  "extern monst_base \n";
	my $mbl = ("\t" . (join ",\n\t", @full_mbl, @auto_mbl) . ",\n"); $mbl =~ s/\&//g;
	print MBH $mbl;

	print MBH  "    dumby_monster_base;\n";
	print MBH  "\n";

	print MBH  "#ifndef IN_MONSTBASE_CC\n";
	print MBH  "   extern monst_base *mb_list_all[], *mb_list_eatable[], *mb_list_attackable[];\n";
	print MBH  "#else\n";

	print MBH  "monst_base *mb_list_all[] = {\n";
	print MBH  "\t" . (join ",\n\t", @full_mbl, @auto_mbl) . ",\n\tNULL\n";
	print MBH  "};\n";
	print MBH  "\n";

	print MBH  "monst_base *mb_list_eatable[] = {\n";
	print MBH  "    NULL\n";
	print MBH  "};\n";
	print MBH  "\n";

	print MBH  "monst_base *mb_list_attackable[] = {\n";
	print MBH  "    NULL\n";
	print MBH  "};\n";
	print MBH  "\n";

	print MBH  "monst_base dumby_monster_base;\n";
	print MBH  "\n";

	print MBH  "#endif\n";
	print MBH  "#define FOR_EACH_SPAWN_NUM \\\n";
	foreach my $sp ( @full_mbl) {
		$sp =~ s/\&mb_//;
		print MBH "\tSPAWN_NUM($sp) \\\n";
	}
	print MBH  "/* MACRO END */\n";
	print MBH  "\n";

	print MBH  "/* EOF. */\n";

	close MBH;
}

# -------------------- MAIN ------------------------

if (open TF, "inventory.cc") {
        $recno = 0;
	load_sprites_h();
        load_sounds_h();	
	load_monstbase_cc();
	open $SP, ">sprite_patch.h" or die "Couldn't create sprite_patch.h";
	write_patch_header();
	open $AB, ">auto_monstbase.inc" or die "Couldn't create auto_monstbase.inc";
	print $AB "/* auto_monstbase.inc generated by trader_strip.pl */\n\n";
  	while (defined (my $ln = <TF>)) {
                $output = 1 if $ln =~ /LIST BEGIN/;
		$output = 0 if $ln =~ /LIST END/;
		if ($output && $ln !~ /(BEGIN|END)/) {
			$ln =~ s/\t|\n//g;
                        $ln =~ s/\/\/.*//;
                        $ln =~ s/\/\*.*?\*\///g; # only pays attention to a comment on one line
			if ($ln =~ /(UP|CAGE|CLAW|HULL|THRUST|AUTO|PROJ|DEPL)\((.*?)\)/) {
                                my $macro = $1; my $agl = $2;
                                $agl =~ s/^\s*//;$agl =~ s/\s*$//;
                                my @args = split( /,\s*/, $agl);
                                my ($pre, $post, $desc, $class, $size, $hp, $inam, $base_name, $lspr, $bspr);
                                $class = lc $macro;
                                $size = 400; $hp = 1000;
                                my $xflags = '';
                    		my $ai_func = 'ai_item';

                                if ($macro eq 'UP') {
                                	push @firsts, "#define FIRST_" . uc $args[0] . "_IDX $recno\n" if ($auto_count{$args[0]} == 0);
                                  	$inam = uc $args[0] . $args[2];
                                	push @needspr, "$args[7]";
                                  	$class = $args[0];
                                  	$desc = $args[1];
                                  	$auto_count{$args[0]}++;
                                } elsif ($macro eq 'CAGE') {
                                	push @firsts, "#define FIRST_INV_CAGE_IDX $recno\n" if ($auto_count{inv_cage} == 0);
                                  	$inam = uc "cage$args[1]";
                                	push @needspr, "$args[6]", "$args[7]" , "$args[7]_BROKEN";
                                        $lspr = "SPR_$args[7]";
                                  	$bspr = "SPR_$args[6]";
                                	$desc = $args[0];
                                	$auto_count{inv_cage}++;
                                } elsif ($macro eq 'HULL') {
                                        push @firsts, "#define FIRST_INV_HULL_IDX $recno\n" if ($auto_count{inv_hull} == 0);
                                  	$inam = uc "hull$args[1]";
	                               	push @needspr, "$args[6]", "$args[7]";
	                               	$desc = $args[0];
	                               	$auto_count{inv_hull}++;
                                } elsif ($macro eq 'THRUST') {
                                  	$inam = uc "thrust$args[1]";
	                               	push @needspr, "$args[8]";
	                               	$desc = $args[0];
                                } elsif ($macro eq 'CLAW') {
                                  	$inam = uc "claw$args[1]";
                                	push @needspr, "$args[6]", "$args[7]" , "$args[7]_CLOSED";
                                	$desc = $args[0];
                                } elsif ($macro eq 'AUTO') {
                                	push @firsts, "#define FIRST_" . uc $args[0] . "_IDX $recno\n" if ($auto_count{$args[0]} == 0);
                                  	push @needspr, "$args[6]_INV", "$args[6]";
                                        $lspr = "SPR_$args[6]";
                                  	$bspr = "SPR_$args[6]_INV";
                                  	$inam = uc "$args[1]";
                                  	$class = $args[0];
                                  	$auto_count{$args[0]}++;
                                  	$desc = $args[1];
                                  	$size = 200;
                                } elsif ($macro eq 'DEPL') {
#  define DEPL( typ, nam, lvl, sv, sv2_tox, size, hp, jm, cost, common, inv_sprite, lil_sprite)
                                	push @needspr, "$args[10]", "$args[11]";
                                        $lspr = "SPR_$args[11]";
                                  	$bspr = "SPR_$args[10]";
                                  	$inam = uc "$args[1]";
                                  	$class = $args[0];
                                  	$auto_count{$args[0]}++;
                                  	$desc = $args[1];
                                        $size = $args[5];
                                        $hp = $args[6];
                                 	$xflags .= ' | AF_NOHOOK | AF_SPARKS';
                                 	$xflags .= ' | AF_AGRLIST' if ($args[0] eq 'inv_tower' && $inam !~ /RAIDER/i);
                                 	$xflags .= ' | AF_NOSHOOT' if $args[0] eq 'inv_stabilizer';
                    			$ai_func = ($args[0] eq 'inv_tower' ? 'ai_turret' : 'ai_building');
                                } elsif ($macro eq 'PROJ') {
                                	push @needspr, "$args[12]", "$args[13]", "$args[16]", "$args[17]";
                                        push @needsnd, "$args[18]";                                	
                                	$inam = uc "$args[1]";
                                        $lspr = ($args[16] eq "NONE" ? "SPR_$args[13]" : "SPR_$args[16]");
                                  	$bspr = "SPR_$args[12]";
                                	$class = 'weapon';
                                	$desc = $args[1];
                                }
                                $inam = uc $inam;
                                $inam =~ s/^INV_//ig;
                                $inam =~ s/[^A-Z0-9]//g;

                                print  $SP "#define IDF_$inam\tivalu_list[$recno]\n";

                                $class =~ s/^inv_//;
	                        $class =~ s/_/ /g;
	                        $class =~ s/ ([a-z])/' ' . uc $1/ge;
	                        $class =~ s/^([a-z])/uc $1/e;
                                $base_name = lc $inam;
				$bspr =~ s/^SPR_//;   $lspr =~ s/^SPR_//;
        		        if ($macro eq 'AUTO' || $macro eq 'PROJ' || $macro eq 'DEPL' || $macro eq 'CAGE') {
                                            my $spr_chill = ( $has_chill{$base_name} ? "" : (lc $class) eq 'tower' ? "SPR_CHILL($base_name, Y($lspr, 18, 18),)" : "SPR_CHILL($base_name, W($lspr),)");
                                            my $spr_big   = ( ! $has_big{$base_name} ? "SPR_BIG($base_name, $bspr)" : "");
                                            my $spr_die   = ( ! $has_die{$base_name} ? "SPR_DIE($base_name, W(DEBRIES),)" : "");
                                            my $soundtab = ("NO_SOUND($base_name)");
                                            print $AB "$spr_big $spr_chill $spr_die $soundtab\n";
                                            print $AB "monst_base mb_$base_name = {  BUILDING($base_name, $desc, \"$class\", \"\", $ai_func, $hp, $size, AF_INORGANIC | AF_ASEXUAL$xflags ) };\n\n";
                                            $fix_desc_func .= "\tmb_$base_name.org_idx = " . ($macro ne 'DEPL' ? 'org_inanim' : $base_name =~ /raid/ ? "org_raiders" : "org_ast0") . ";\n";
                                            $fix_desc_func .= "\tmb_$base_name.desc = IDF_$inam.desc;\n";
                                            $fix_desc_func .= "\tmb_$base_name.inv_link = &IDF_$inam;\n";
                                            $fix_desc_func .= "\tIDF_$inam.mb_link = &mb_$base_name;\n\n";
					    push @auto_mbl, "\&mb_$base_name";
                    		}
                            	print "[$macro] $base_name : (" . join(', ',@args) . ")\n";
                            	$recno++;
			} elsif ($ln =~ /^\s*$/) {
    				print "\n";
    				print $SP "\n";
			} else { print "//no match: $ln\n"; }
         	}
	}

	print $AB "\nvoid auto_fix_desc() {\n$fix_desc_func}\n\n";
	my $ls;
	print $SP "\n";
	print $SP (sort @firsts);
	print $SP "\n";
	foreach my $schk (sort (keys %auto_count)) {
		print $SP "#define NUM_" . (uc $schk) . " $auto_count{$schk}\n";
	}
	print $SP "#define NUM_IVALU_LIST $recno\n\n";
	foreach my $schk (sort @needspr) {
		if (! $have_sprites{"SPR_$schk"} && $ls ne $schk) {
			my $def =  (
				$schk =~ /_INV$/ ? "SPR_NO_BIG_PIC" :
				$schk =~ /A.?0001/ ? "SPR_AA0001" :
				$schk =~ /MIS_/ ? "SPR_50CAL_T0" : "SPR_NO_LIL_PIC"
			);
			print  $SP "#define SPR_$schk $def\n";
		}
		$ls = $schk;
	}
	foreach my $schk (sort @needsnd) {
		if (! $have_sounds{"SND_$schk"} && $ls ne $schk) {
			my $def =  ( "-1");
			print  $SP "#define SND_$schk $def\n";
		}
		$ls = $schk;
	}
	print $SP "extern ivalu_t ivalu_list[NUM_IVALU_LIST];\n";
	print $SP "#define AST_LIST_ITEMS {$ast_list}\n";
	print $SP "#endif\n";
	close $SP;
	close $AB;

	close TF;
	write_monstbase_h;

}


